; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	d:\paste\otc\dllmain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@ ; `string'
PUBLIC	??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@ ; `string'
PUBLIC	??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@ ; `string'
PUBLIC	??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@ ; `string'
PUBLIC	??_C@_0EH@CFBGKODN@?$HM?5?$FL?$CB?$FN?5Could?5not?5find?5the?5msvc?5r@ ; `string'
PUBLIC	??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@ ; `string'
PUBLIC	??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@ ; `string'
PUBLIC	??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@ ; `string'
PUBLIC	??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@ ; `string'
PUBLIC	??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@ ; `string'
PUBLIC	??_C@_0DI@CFAIMOHN@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5framework?5@ ; `string'
PUBLIC	??_C@_0DC@MPINGACN@?$HM?5?$FL?$HO?$FN?5Filling?5the?5dependency?5ta@ ; `string'
PUBLIC	??_C@_0BK@JDCGCNGO@?$HM?5?$FL?$HO?$FN?5Updating?5netvars?4?4?4@ ; `string'
PUBLIC	??_C@_0DC@FNBEDFB@?$HM?5?$FL?$HO?$FN?5Install?5hook?5for?5virtual?5@ ; `string'
PUBLIC	??_C@_0BM@FALAIJHL@?$HM?5?$FL?$HO?$FN?5Updating?5watermark?4?4?4@ ; `string'
PUBLIC	??_C@_03MEDKAJNC@?5?$DP?5@			; `string'
PUBLIC	??_C@_0BG@DLJKLACG@?$HM?5?$FL?$HO?$FN?5Invoking?5OEP?4?4?4@ ; `string'
PUBLIC	??_C@_0CK@CANJDOLL@?$HM?5?$FL?$CL?$FN?5All?5loader?5procedures?5fin@ ; `string'
PUBLIC	??_C@_0L@PHFEFMEF@client?4dll@			; `string'
PUBLIC	??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@		; `string'
PUBLIC	??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@		; `string'
PUBLIC	??_C@_0M@EINGCJHB@vstdlib?4dll@			; `string'
PUBLIC	??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@ ; `string'
PUBLIC	??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@ ; `string'
PUBLIC	??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@ ; `string'
PUBLIC	??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@ ; `string'
PUBLIC	??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@ ; `string'
PUBLIC	??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@ ; `string'
PUBLIC	??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@ ; `string'
PUBLIC	??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@ ; `string'
PUBLIC	??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@ ; `string'
PUBLIC	??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@ ; `string'
PUBLIC	??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@ ; `string'
PUBLIC	??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@ ; `string'
PUBLIC	??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@ ; `string'
PUBLIC	??_C@_0M@MACNFAAE@B0?501?583?5FE@		; `string'
PUBLIC	??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@ ; `string'
PUBLIC	??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@ ; `string'
PUBLIC	??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@ ; `string'
PUBLIC	??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@ ; `string'
PUBLIC	??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@ ; `string'
PUBLIC	??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@ ; `string'
PUBLIC	??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@ ; `string'
PUBLIC	??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@ ; `string'
PUBLIC	??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@ ; `string'
PUBLIC	??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@ ; `string'
PUBLIC	??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@ ; `string'
PUBLIC	??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@ ; `string'
PUBLIC	??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@ ; `string'
PUBLIC	??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@	; `string'
PUBLIC	??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@ ; `string'
PUBLIC	??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@ ; `string'
PUBLIC	??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@ ; `string'
PUBLIC	??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@ ; `string'
PUBLIC	??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@ ; `string'
PUBLIC	??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@ ; `string'
PUBLIC	??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@ ; `string'
PUBLIC	??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@ ; `string'
PUBLIC	??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@ ; `string'
PUBLIC	??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@ ; `string'
PUBLIC	??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@ ; `string'
PUBLIC	??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@ ; `string'
PUBLIC	??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@ ; `string'
PUBLIC	??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@ ; `string'
PUBLIC	??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@ ; `string'
PUBLIC	??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@ ; `string'
PUBLIC	??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@ ; `string'
PUBLIC	??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@	; `string'
PUBLIC	??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@ ; `string'
PUBLIC	??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@	; `string'
PUBLIC	??_C@_0P@CGNIIJII@75?504?5B0?501?55F@		; `string'
PUBLIC	??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@	; `string'
PUBLIC	??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@ ; `string'
PUBLIC	??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@ ; `string'
PUBLIC	??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@ ; `string'
PUBLIC	??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@ ; `string'
PUBLIC	??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@ ; `string'
PUBLIC	??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@ ; `string'
PUBLIC	??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@ ; `string'
PUBLIC	??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@ ; `string'
PUBLIC	??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@ ; `string'
PUBLIC	??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@ ; `string'
PUBLIC	??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@ ; `string'
PUBLIC	??_C@_0M@OEHPONHC@75?54B?50F?557@		; `string'
PUBLIC	??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@ ; `string'
PUBLIC	??_C@_0M@OFBMICFD@56?58D?551?53C@		; `string'
PUBLIC	??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@ ; `string'
PUBLIC	??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@ ; `string'
PUBLIC	??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@ ; `string'
PUBLIC	??_C@_0M@GHAFGLNO@8D?54E?574?58B@		; `string'
PUBLIC	??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@ ; `string'
PUBLIC	??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@ ; `string'
PUBLIC	??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@ ; `string'
PUBLIC	??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@ ; `string'
PUBLIC	??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@ ; `string'
PUBLIC	??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@ ; `string'
PUBLIC	??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@ ; `string'
PUBLIC	?OriginalVirtualCaller@SegmentFramework@@2P6IIPAXH@ZA ; SegmentFramework::OriginalVirtualCaller
PUBLIC	?UnsafeAllocatedPointer@Segment@@2KA		; Segment::UnsafeAllocatedPointer
PUBLIC	?UnsafeLibraryPointer@Segment@@2KA		; Segment::UnsafeLibraryPointer
?OriginalVirtualCaller@SegmentFramework@@2P6IIPAXH@ZA DD 01H DUP (?) ; SegmentFramework::OriginalVirtualCaller
?UnsafeAllocatedPointer@Segment@@2KA DD 01H DUP (?)	; Segment::UnsafeAllocatedPointer
?UnsafeLibraryPointer@Segment@@2KA DD 01H DUP (?)	; Segment::UnsafeLibraryPointer
_BSS	ENDS
;	COMDAT ??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@
CONST	SEGMENT
??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@ DB '55 8B EC 83 EC'
	DB	' 48 53 8B 5D', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@
CONST	SEGMENT
??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@ DB '55 8B E'
	DB	'C 83 E4 F8 51 53 56 8B D9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@
CONST	SEGMENT
??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@ DB 'A2 ? ? ? ?'
	DB	' 8B 45 E8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@
CONST	SEGMENT
??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@ DB 'FF 50 18 89 44 24 '
	DB	'14 EB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@
CONST	SEGMENT
??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@ DB '55 8B E'
	DB	'C 83 E4 F8 8B 45 0C 83 EC 10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@
CONST	SEGMENT
??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@ DB '55 8B EC'
	DB	' F3 0F 10 45 ? 56 6A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@
CONST	SEGMENT
??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@ DB '8'
	DB	'B 0D ? ? ? ? F6 87 ? ? ? ? ? 8B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHAFGLNO@8D?54E?574?58B@
CONST	SEGMENT
??_C@_0M@GHAFGLNO@8D?54E?574?58B@ DB '8D 4E 74 8B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
CONST	SEGMENT
??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@ DB 'E'
	DB	'8 ? ? ? ? 8B 0D ? ? ? ? 0F 57 C9 99', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
CONST	SEGMENT
??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@ DB 'E8 ? ? ? ? 99 '
	DB	'2B', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 E4 F8 81 EC ? ? ? ? A1 ? ? ? ? 53 56 8B D9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@
CONST	SEGMENT
??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@ DB 'E'
	DB	'8 ? ? ? ? 83 7D D8 00 7C 0F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFBMICFD@56?58D?551?53C@
CONST	SEGMENT
??_C@_0M@OFBMICFD@56?58D?551?53C@ DB '56 8D 51 3C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@
CONST	SEGMENT
??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@ DB '0'
	DB	'F B7 05 ? ? ? ? 3D ? ? ? ? 74 3F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEHPONHC@75?54B?50F?557@
CONST	SEGMENT
??_C@_0M@OEHPONHC@75?54B?50F?557@ DB '75 4B 0F 57', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@
CONST	SEGMENT
??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@ DB 'E'
	DB	'8 ? ? ? ? 8B 46 04 5F 5E 5B 8B E5 5D C2 08 00 6A', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@
CONST	SEGMENT
??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@ DB 'E'
	DB	'8 ? ? ? ? 8B D0 85 D2 75 07 32 C0 5F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@
CONST	SEGMENT
??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@ DB 'E'
	DB	'8 ? ? ? ? EB 02 33 C0 57 8B BE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@
CONST	SEGMENT
??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@ DB '83 B'
	DB	'E ? ? ? ? ? 7F 67', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@
CONST	SEGMENT
??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@ DB '8'
	DB	'B 35 ? ? ? ? FF 10 0F B7 C0 B9 ? ? ? ? 50 FF 56 08 85', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@ DB '8'
	DB	'0 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@
CONST	SEGMENT
??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@ DB 'E8 ? ?'
	DB	' ? ? FF 76 0C 8D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@
CONST	SEGMENT
??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@ DB 'FF D0 A1 ?'
	DB	' ? ? ? B9', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@
CONST	SEGMENT
??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@ DB 'F3 0F 10 4D '
	DB	'? 84 C0 74 12', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@
CONST	SEGMENT
??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@ DB '5'
	DB	'5 8B EC 81 EC ? ? ? ? 53 56 57 8B D9 E8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@
CONST	SEGMENT
??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@ DB '84 C0 7'
	DB	'5 09 5F 5E 5B 8B E5 5D C2 14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@
CONST	SEGMENT
??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@ DB '8'
	DB	'4 C0 75 38 8B 0D ? ? ? ? 8B 01 8B 80', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@
CONST	SEGMENT
??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@ DB '84 C0 75 0D F6 87', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CGNIIJII@75?504?5B0?501?55F@
CONST	SEGMENT
??_C@_0P@CGNIIJII@75?504?5B0?501?55F@ DB '75 04 B0 01 5F', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@
CONST	SEGMENT
??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@ DB '85 C0 74 2D 83 7D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@
CONST	SEGMENT
??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@ DB 'C7 46 ? '
	DB	'? ? ? ? 43', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@
CONST	SEGMENT
??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@ DB '85 C0 75 30 38 86', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@
CONST	SEGMENT
??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@ DB '55 8B E'
	DB	'C 56 FF 75 08 8B F1 8B 06 FF 90 ? ? ? ? 8B 86', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@
CONST	SEGMENT
??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 30 56 57 8B 3D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@
CONST	SEGMENT
??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 5C 53 8B D9 56 57 83 7B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@
CONST	SEGMENT
??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@ DB '5'
	DB	'7 8B F9 8B 07 8B 80 ? ? ? ? FF D0 84 C0 75 02', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@
CONST	SEGMENT
??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@ DB '5'
	DB	'5 8B EC 83 EC 10 A1 ? ? ? ? 89 4D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@
CONST	SEGMENT
??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@ DB '5'
	DB	'6 8B F1 8B 0D ? ? ? ? 57 8B 01 FF 76 70', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@
CONST	SEGMENT
??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@ DB 'F'
	DB	'3 0F 10 A6 ? ? ? ? F3 0F 11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@
CONST	SEGMENT
??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 1C 53 56 57 8B F9 F7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@
CONST	SEGMENT
??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@
CONST	SEGMENT
??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 0C 53 56 57 8B 7D 08 8B F1 F3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@
CONST	SEGMENT
??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@ DB '55 8B E'
	DB	'C 56 8B 75 08 57 FF 75 18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@
CONST	SEGMENT
??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@ DB '53 56 8B F1 57 8B '
	DB	'4E 3C', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@
CONST	SEGMENT
??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@ DB '55 8B EC 83 EC 58 '
	DB	'56 57', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@ DB '8'
	DB	'B 01 FF B1 ? ? ? ? FF 90 ? ? ? ? 83', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@
CONST	SEGMENT
??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@ DB '5'
	DB	'5 8B EC 56 8B 35 ? ? ? ? 85 F6 0F 84 ? ? ? ? 81', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@
CONST	SEGMENT
??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@ DB '55 8B EC 8D 51'
	DB	' 08 8B 4D 08', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@
CONST	SEGMENT
??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@ DB '55 8B E'
	DB	'C 83 E4 F0 83 EC 7C 56 FF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@
CONST	SEGMENT
??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@ DB '8B 97 ? ? '
	DB	'? ? 56 8B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@ DB '8'
	DB	'4 C0 74 0A F3 0F 10 05 ? ? ? ? EB 05', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@
CONST	SEGMENT
??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@ DB '84 C0 74 17 8B 87', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@
CONST	SEGMENT
??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@ DB '0'
	DB	'F 84 ? ? ? ? 8B 88 ? ? ? ? 83 F9 FF 0F 84 ? ? ? ? 0F B7 C1 C1'
	DB	' E0 04 05 ? ? ? ? C1 E9 10 39 48 04 0F 85 ? ? ? ? 8B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@
CONST	SEGMENT
??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@ DB '55 8B E'
	DB	'C 51 53 56 8B 75 08 8B D9 57 6B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@
CONST	SEGMENT
??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@ DB 'B'
	DB	'9 ? ? ? ? E8 ? ? ? ? 85 C0 74 0A 8B 10 8B C8 FF A2 AC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@
CONST	SEGMENT
??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@ DB '55 8B EC 8'
	DB	'3 EC 0C 53 56 8B 71', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@ DB 'B'
	DB	'9 ? ? ? ? A3 ? ? ? ? E8 ? ? ? ? 5D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@
CONST	SEGMENT
??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@ DB '55 8B E'
	DB	'C 56 8B 75 0C 57 8B F9 B9 ? ? ? ? 89', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@
CONST	SEGMENT
??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@ DB '55 8B E'
	DB	'C 53 8B 5D 08 56 57 8B F9 33 F6 39', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@
CONST	SEGMENT
??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@ DB 'A1 ? ? ? ? 74 '
	DB	'38', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@
CONST	SEGMENT
??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@ DB '8'
	DB	'3 3D ? ? ? ? ? 57 8B F9 75 06', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@
CONST	SEGMENT
??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@ DB '80 B'
	DB	'9 ? ? ? ? ? 75 6C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 EC 08 8B 15 ? ? ? ? 0F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@
CONST	SEGMENT
??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@ DB 'C'
	DB	'7 00 ? ? ? ? E8 ? ? ? ? 83 EC 08 8D 4E 74', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@
CONST	SEGMENT
??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@ DB '5'
	DB	'5 8B EC 51 56 8B 35 ? ? ? ? 57 83', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@
CONST	SEGMENT
??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@ DB '8'
	DB	'1 C6 ? ? ? ? 8B 4E 0C 8B 56 04 89 4D E4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@
CONST	SEGMENT
??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@ DB 'B9 ? ?'
	DB	' ? ? FF 50 14 5F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MACNFAAE@B0?501?583?5FE@
CONST	SEGMENT
??_C@_0M@MACNFAAE@B0?501?583?5FE@ DB 'B0 01 83 FE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@
CONST	SEGMENT
??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@ DB '0F 44 C8'
	DB	' 33 C0 5E 39 11 0F 94 C0 C3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@
CONST	SEGMENT
??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@ DB 'B'
	DB	'9 ? ? ? ? A1 ? ? ? ? FF 10 A1 ? ? ? ? B9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@
CONST	SEGMENT
??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@ DB '8'
	DB	'B 35 ? ? ? ? FF 90 ? ? ? ? 50 B9 ? ? ? ? FF 56 24 5E C3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@ DB '5'
	DB	'5 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@
CONST	SEGMENT
??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@ DB '55 8'
	DB	'B EC FF 75 18 F3 0F 10 45 ? 51', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 E4 F8 81 EC ? ? ? ? 53 56 8B F1 57 89 74 24 1C', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@
CONST	SEGMENT
??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@ DB '55 8B EC 56 8B F1 '
	DB	'51 8D', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@
CONST	SEGMENT
??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@ DB '8B'
	DB	' 0D ? ? ? ? 8B 46 08 68', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@
CONST	SEGMENT
??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@ DB '55 8B E'
	DB	'C 83 E4 C0 83 EC 34 53 56 8B 75', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@
CONST	SEGMENT
??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@ DB '55 8B E'
	DB	'C 53 8B 5D 08 56 8B F1 83', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@
CONST	SEGMENT
??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@ DB '51 56 8B F1 85'
	DB	' F6 74 68 83', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@
CONST	SEGMENT
??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 64 53 56 57 8B F1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@
CONST	SEGMENT
??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@ DB '55 8B E'
	DB	'C 83 E4 F8 51 53 56 57 8B F1 E8 ? ? ? ? 8B 7D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@
CONST	SEGMENT
??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@ DB '56'
	DB	' 6A 01 68 ? ? ? ? 8B F1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@
CONST	SEGMENT
??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 70 6A 58', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EINGCJHB@vstdlib?4dll@
CONST	SEGMENT
??_C@_0M@EINGCJHB@vstdlib?4dll@ DB 'vstdlib.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@
CONST	SEGMENT
??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@ DB 'shaderapidx9.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@
CONST	SEGMENT
??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@ DB 'vguimatsurface.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHFEFMEF@client?4dll@
CONST	SEGMENT
??_C@_0L@PHFEFMEF@client?4dll@ DB 'client.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CANJDOLL@?$HM?5?$FL?$CL?$FN?5All?5loader?5procedures?5fin@
CONST	SEGMENT
??_C@_0CK@CANJDOLL@?$HM?5?$FL?$CL?$FN?5All?5loader?5procedures?5fin@ DB '|'
	DB	' [+] All loader procedures finished. Gl.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DLJKLACG@?$HM?5?$FL?$HO?$FN?5Invoking?5OEP?4?4?4@
CONST	SEGMENT
??_C@_0BG@DLJKLACG@?$HM?5?$FL?$HO?$FN?5Invoking?5OEP?4?4?4@ DB '| [~] Inv'
	DB	'oking OEP...', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEDKAJNC@?5?$DP?5@
CONST	SEGMENT
??_C@_03MEDKAJNC@?5?$DP?5@ DB ' ? ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FALAIJHL@?$HM?5?$FL?$HO?$FN?5Updating?5watermark?4?4?4@
CONST	SEGMENT
??_C@_0BM@FALAIJHL@?$HM?5?$FL?$HO?$FN?5Updating?5watermark?4?4?4@ DB '| ['
	DB	'~] Updating watermark...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FNBEDFB@?$HM?5?$FL?$HO?$FN?5Install?5hook?5for?5virtual?5@
CONST	SEGMENT
??_C@_0DC@FNBEDFB@?$HM?5?$FL?$HO?$FN?5Install?5hook?5for?5virtual?5@ DB '|'
	DB	' [~] Install hook for virtual function caller...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JDCGCNGO@?$HM?5?$FL?$HO?$FN?5Updating?5netvars?4?4?4@
CONST	SEGMENT
??_C@_0BK@JDCGCNGO@?$HM?5?$FL?$HO?$FN?5Updating?5netvars?4?4?4@ DB '| [~]'
	DB	' Updating netvars...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MPINGACN@?$HM?5?$FL?$HO?$FN?5Filling?5the?5dependency?5ta@
CONST	SEGMENT
??_C@_0DC@MPINGACN@?$HM?5?$FL?$HO?$FN?5Filling?5the?5dependency?5ta@ DB '|'
	DB	' [~] Filling the dependency table... (~7-15 sec)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CFAIMOHN@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5framework?5@
CONST	SEGMENT
??_C@_0DI@CFAIMOHN@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5framework?5@ DB '|'
	DB	' [+] Wait until the framework complete routine work...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@
CONST	SEGMENT
??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@ DB '|'
	DB	' [~] Reconstructing hot-points...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@
CONST	SEGMENT
??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@ DB '|'
	DB	' [~] Extracting segment to memory....', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@
CONST	SEGMENT
??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@ DB '| [+] A'
	DB	'll checks passed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@
CONST	SEGMENT
??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@ DB '|'
	DB	' [+] Found the required msvc redist build on your system.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@
CONST	SEGMENT
??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@ DB '|'
	DB	' [~] You can download and install the redist build from here:'
	DB	' https://www.microsoft.com/en-us/download/confirmation.aspx?i'
	DB	'd=52685.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CFBGKODN@?$HM?5?$FL?$CB?$FN?5Could?5not?5find?5the?5msvc?5r@
CONST	SEGMENT
??_C@_0EH@CFBGKODN@?$HM?5?$FL?$CB?$FN?5Could?5not?5find?5the?5msvc?5r@ DB '|'
	DB	' [!] Could not find the msvc redist package installed on your'
	DB	' system.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@
CONST	SEGMENT
??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@ DB '|'
	DB	' [+] Your windows version meets the requirements for running '
	DB	'OTC.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@
CONST	SEGMENT
??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@ DB '|'
	DB	' [~] Please upgrade to 7 or 8, or 10. (PC build)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@
CONST	SEGMENT
??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@ DB '|'
	DB	' [-] I cannot run OTC on the current version of Windows.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@
CONST	SEGMENT
??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@ DB '|'
	DB	' [~] Performing basic checks...', 00H	; `string'
PUBLIC	??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>
PUBLIC	??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z ; std::_Copy_memmove<char const * const *,char const * *>
PUBLIC	??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>
PUBLIC	??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>
PUBLIC	??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z ; std::_Unfancy<SegmentFramework::RelocatedNetVar>
PUBLIC	??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z	; std::_Get_unwrapped<char const * const * const &>
PUBLIC	??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >
PUBLIC	??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z ; std::forward<std::less<char const *> const &>
PUBLIC	??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z ; std::distance<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>
PUBLIC	??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>
PUBLIC	??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>
PUBLIC	??$distance@PBQBD@std@@YAHPBQBD0@Z		; std::distance<char const * const *>
PUBLIC	??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z ; std::forward<std::allocator<char const *> const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
PUBLIC	?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
PUBLIC	?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
PUBLIC	?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
PUBLIC	?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
PUBLIC	?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >
PUBLIC	?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>
PUBLIC	??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>
PUBLIC	??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>
PUBLIC	??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate
PUBLIC	?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate
PUBLIC	?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy
PUBLIC	?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
PUBLIC	?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy
PUBLIC	?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
PUBLIC	?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin
PUBLIC	?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end
PUBLIC	?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ	; std::initializer_list<char const *>::begin
PUBLIC	?end@?$initializer_list@PBD@std@@QBEPBQBDXZ	; std::initializer_list<char const *>::end
PUBLIC	??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >
PUBLIC	??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
PUBLIC	??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>
PUBLIC	??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??0?$allocator@PBD@std@@QAE@XZ			; std::allocator<char const *>::allocator<char const *>
PUBLIC	??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
PUBLIC	??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>
PUBLIC	??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z	; std::initializer_list<char const *>::initializer_list<char const *>
PUBLIC	?__autoclassinit2@Segment@@QAEXI@Z		; Segment::__autoclassinit2
PUBLIC	??1Segment@@QAE@XZ				; Segment::~Segment
PUBLIC	??0SegmentFramework@@QAE@XZ			; SegmentFramework::SegmentFramework
PUBLIC	??0Segment@@QAE@XZ				; Segment::Segment
PUBLIC	_DllMain@12
PUBLIC	??0RuntimeHandler@@QAE@AAVSegment@@@Z		; RuntimeHandler::RuntimeHandler
PUBLIC	??1SegmentFramework@@QAE@XZ			; SegmentFramework::~SegmentFramework
PUBLIC	??0SegmentFramework@@QAE@ABV0@@Z		; SegmentFramework::SegmentFramework
PUBLIC	?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
PUBLIC	??0SegmentHeader@@QAE@XZ			; SegmentHeader::SegmentHeader
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentHeader@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentHeader@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentHeader@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentHeader@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentHeader@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentFramework@@QAE@ABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentFramework@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentFramework@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_DllMain@12 DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$_DllMain@12
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$_DllMain@12 DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$9
	DD	00H
	DD	FLAT:__unwindfunclet$_DllMain@12$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$0
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$1
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$2
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$3
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$4
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$5
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Segment@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Segment@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Segment@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentFramework@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentFramework@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentFramework@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@XZ$1
; Function compile flags: /Ogtp
; File D:\paste\OTC\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File D:\paste\OTC\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File D:\paste\OTC\headers\segment\SegmentHeader.h
;	COMDAT ??0SegmentHeader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SegmentHeader@@QAE@XZ PROC				; SegmentHeader::SegmentHeader, COMDAT
; _this$ = ecx

; 50   :     SegmentHeader () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentHeader@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002b	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00033	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00042	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00044	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00047	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0004a	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00050	89 06		 mov	 DWORD PTR [esi], eax
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00059	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00060	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00067	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  0006e	8b ce		 mov	 ecx, esi
  00070	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00074	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations

; 53   :     }

  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5e		 pop	 esi
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentHeader@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0SegmentHeader@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SegmentHeader@@QAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentHeader@@QAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentHeader@@QAE@XZ ENDP				; SegmentHeader::SegmentHeader
; Function compile flags: /Ogtp
; File D:\paste\OTC\headers\segment\Segment.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File D:\paste\OTC\headers\segment\Segment.h
;	COMDAT ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -28				; size = 4
_this$GSCopy$1$ = -24					; size = 4
__Rightlast$1$ = -20					; size = 4
__Count$1$ = -20					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Rightfirst$1$ = -16					; size = 4
__Rightfirst$1$ = -16					; size = 4
__Count$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ PROC	; Segment::GetFramework, COMDAT
; _this$ = ecx

; 43   : 	SegmentFramework GetFramework() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 45 e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  0002d	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00030	89 5d e4	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00039	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00047	8b 50 14	 mov	 edx, DWORD PTR [eax+20]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0004a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004d	89 55 ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00050	3b d1		 cmp	 edx, ecx
  00052	74 2c		 je	 SHORT $LN28@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00054	2b ca		 sub	 ecx, edx
  00056	8b f9		 mov	 edi, ecx
  00058	89 4d f0	 mov	 DWORD PTR __Count$1$[ebp], ecx
  0005b	c1 ff 03	 sar	 edi, 3
  0005e	8b cb		 mov	 ecx, ebx
  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00066	ff 75 f0	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00069	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0006b	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00074	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0007a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0007d	8b 45 e8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
$LN28@GetFramewo:
  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00087	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0008e	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00095	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0009f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000a2	89 55 f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000a5	3b d1		 cmp	 edx, ecx
  000a7	74 2e		 je	 SHORT $LN69@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000a9	2b ca		 sub	 ecx, edx
  000ab	8b f9		 mov	 edi, ecx
  000ad	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx
  000b0	c1 ff 02	 sar	 edi, 2
  000b3	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000bc	ff 75 ec	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000bf	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c2	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  000cb	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000d1	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000d4	8b 45 e8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
$LN69@GetFramewo:
  000d7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000db	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], 0
  000e2	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0
  000e9	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  000f0	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000f3	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  000f6	89 4d f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000f9	3b c8		 cmp	 ecx, eax
  000fb	74 2b		 je	 SHORT $LN132@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000fd	2b c1		 sub	 eax, ecx
  000ff	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00102	8b f8		 mov	 edi, eax
  00104	89 45 ec	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00107	c1 ff 02	 sar	 edi, 2
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00110	ff 75 ec	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00113	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00116	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00119	56		 push	 esi
  0011a	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0011f	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00125	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
$LN132@GetFramewo:
; File D:\paste\OTC\headers\segment\Segment.h

; 45   : 	}

  00128	8b c3		 mov	 eax, ebx
  0012a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00134	59		 pop	 ecx
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$1:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$2:
  00008	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ENDP	; Segment::GetFramework
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0SegmentFramework@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
___that$GSCopy$1$ = -24					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Count$1$ = -20					; size = 4
__Rightlast$1$ = -16					; size = 4
__Count$1$ = -16					; size = 4
__Rightfirst$1$ = -16					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SegmentFramework@@QAE@ABV0@@Z PROC			; SegmentFramework::SegmentFramework, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentFramework@@QAE@ABV0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	89 5d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00039	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00047	8b 10		 mov	 edx, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	89 45 e8	 mov	 DWORD PTR ___that$GSCopy$1$[ebp], eax
  0004f	89 55 f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00052	3b d1		 cmp	 edx, ecx
  00054	74 2c		 je	 SHORT $LN24@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00056	2b ca		 sub	 ecx, edx
  00058	8b f9		 mov	 edi, ecx
  0005a	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx
  0005d	c1 ff 03	 sar	 edi, 3
  00060	8b cb		 mov	 ecx, ebx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00068	ff 75 ec	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0006b	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0006d	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00076	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0007c	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0007f	8b 45 e8	 mov	 eax, DWORD PTR ___that$GSCopy$1$[ebp]
$LN24@SegmentFra:
  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00089	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00090	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00097	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000a1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000a4	89 55 ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000a7	3b d1		 cmp	 edx, ecx
  000a9	74 2e		 je	 SHORT $LN65@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000ab	2b ca		 sub	 ecx, edx
  000ad	8b f9		 mov	 edi, ecx
  000af	89 4d f0	 mov	 DWORD PTR __Count$1$[ebp], ecx
  000b2	c1 ff 02	 sar	 edi, 2
  000b5	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000b8	57		 push	 edi
  000b9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000be	ff 75 f0	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000c1	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c4	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  000cd	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000d3	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000d6	8b 45 e8	 mov	 eax, DWORD PTR ___that$GSCopy$1$[ebp]
$LN65@SegmentFra:
  000d9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000dd	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], 0
  000e4	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0
  000eb	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  000f2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000f5	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000f8	89 4d ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000fb	3b c8		 cmp	 ecx, eax
  000fd	74 2b		 je	 SHORT $LN127@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000ff	2b c1		 sub	 eax, ecx
  00101	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00104	8b f8		 mov	 edi, eax
  00106	89 45 f0	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00109	c1 ff 02	 sar	 edi, 2
  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00112	ff 75 f0	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00115	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00118	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  0011b	56		 push	 esi
  0011c	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00121	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00127	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
$LN127@SegmentFra:
  0012a	8b c3		 mov	 eax, ebx
  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$0:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$1:
  00008	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SegmentFramework@@QAE@ABV0@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentFramework@@QAE@ABV0@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentFramework@@QAE@ABV0@@Z ENDP			; SegmentFramework::SegmentFramework
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1SegmentFramework@@QAE@XZ
_TEXT	SEGMENT
??1SegmentFramework@@QAE@XZ PROC			; SegmentFramework::~SegmentFramework, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00006	85 c0		 test	 eax, eax
  00008	74 45		 je	 SHORT $LN6@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0000d	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00012	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00018	72 16		 jb	 SHORT $LN22@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001d	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00022	83 c0 fc	 add	 eax, -4			; fffffffcH
  00025	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00028	0f 87 b1 00 00
	00		 ja	 $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002e	8b c2		 mov	 eax, edx
$LN22@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00037	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00041	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1699 :             _Myend   = pointer();

  00048	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN6@SegmentFra:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0004f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00052	85 c0		 test	 eax, eax
  00054	74 41		 je	 SHORT $LN31@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00056	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00059	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00064	72 12		 jb	 SHORT $LN47@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00066	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00069	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00071	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00074	77 69		 ja	 SHORT $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00076	8b c2		 mov	 eax, edx
$LN47@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00078	51		 push	 ecx
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  0007f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00086	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00089	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1699 :             _Myend   = pointer();

  00090	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN31@SegmentFra:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	85 c0		 test	 eax, eax
  0009b	74 40		 je	 SHORT $LN55@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0009d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a0	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a2	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ab	72 12		 jb	 SHORT $LN71@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ad	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000b0	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b3	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b5	83 c0 fc	 add	 eax, -4			; fffffffcH
  000b8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000bb	77 22		 ja	 SHORT $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000bd	8b c2		 mov	 eax, edx
$LN71@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000bf	51		 push	 ecx
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  000c6	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  000cc	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  000cf	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  000d6	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN55@SegmentFra:
  000dd	5e		 pop	 esi
  000de	c3		 ret	 0
$LN68@SegmentFra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN76@SegmentFra:
  000e5	cc		 int	 3
??1SegmentFramework@@QAE@XZ ENDP			; SegmentFramework::~SegmentFramework
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\paste\OTC\headers\runtime\RuntimeHandler.h
;	COMDAT ??0RuntimeHandler@@QAE@AAVSegment@@@Z
_TEXT	SEGMENT
_segment$ = 8						; size = 4
??0RuntimeHandler@@QAE@AAVSegment@@@Z PROC		; RuntimeHandler::RuntimeHandler, COMDAT
; _this$ = ecx

; 9    :     RuntimeHandler (Segment& segment) : m_Segment (segment) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _segment$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0RuntimeHandler@@QAE@AAVSegment@@@Z ENDP		; RuntimeHandler::RuntimeHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\paste\OTC\dllmain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File D:\paste\OTC\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File D:\paste\OTC\headers\segment\SegmentHeader.h
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\headers\runtime\RuntimeHandler.h
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\Utils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\otc-priv\OTC\libs\libs\HookLib\HookLib\HookLib\HookLib.c
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\otc-priv\OTC\libs\libs\HookLib\HookLib\HookLib\HookLib.c
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\headers\segment\Segment.h
; File D:\paste\OTC\cpp\utils\Utils.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\headers\segment\Segment.h
; File D:\paste\OTC\cpp\utils\Utils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\runtime\Logger.cpp
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\dllmain.cpp
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp
; File D:\paste\OTC\dllmain.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
$T32 = -436						; size = 36
$T27 = -436						; size = 36
$T24 = -436						; size = 36
$T22 = -436						; size = 36
$T19 = -436						; size = 36
$T18 = -436						; size = 36
_this$ = -400						; size = 4
_runtime$36 = -400					; size = 4
_osVersionInfo$37 = -396				; size = 284
_osVersionInfo$38 = -388				; size = 276
_segment$39 = -112					; size = 56
_logger$40 = -56					; size = 24
_watermark$41 = -32					; size = 16
_watermark$42 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_module$ = 8						; size = 4
_callReason$ = 12					; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 25   : BOOL APIENTRY DllMain (HMODULE module, DWORD callReason, LPVOID lpReserved) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_DllMain@12
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 26   : 
; 27   :     //Developed by, ah cmon, u know who im. 2020.
; 28   :     
; 29   :     if (callReason == DLL_PROCESS_ATTACH) {

  0002d	83 7d 0c 01	 cmp	 DWORD PTR _callReason$[ebp], 1
  00031	0f 85 7f 05 00
	00		 jne	 $LN255@DllMain
  00037	6a 38		 push	 56			; 00000038H
  00039	8d 45 90	 lea	 eax, DWORD PTR _segment$39[ebp]
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _memset
  00044	8d 45 90	 lea	 eax, DWORD PTR _segment$39[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00047	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _segment$39[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0004e	6a 20		 push	 32			; 00000020H
  00050	89 85 70 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00056	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _segment$39[ebp+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0005d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00062	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00065	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00067	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0006a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0006d	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00073	89 45 90	 mov	 DWORD PTR _segment$39[ebp], eax
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0007d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _segment$39[ebp+8], 0
  00084	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _segment$39[ebp+12], 0
  0008b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _segment$39[ebp+16], 0
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  00092	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00095	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00099	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  0009e	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  000a1	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations
  000a6	8d 4d a4	 lea	 ecx, DWORD PTR _segment$39[ebp+20]
  000a9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000b0	e8 00 00 00 00	 call	 ??0SegmentFramework@@QAE@XZ
; File D:\paste\OTC\dllmain.cpp

; 31   :         Segment segment;

  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 32   :         Logger logger (Logger::LoggerType::CONSOLE);

  000bf	6a 00		 push	 0
  000c1	8d 4d c8	 lea	 ecx, DWORD PTR _logger$40[ebp]
  000c4	66 0f d6 45 d8	 movq	 QWORD PTR _logger$40[ebp+16], xmm0
  000c9	0f 11 45 c8	 movups	 XMMWORD PTR _logger$40[ebp], xmm0
  000cd	e8 00 00 00 00	 call	 ??0Logger@@QAE@W4LoggerType@0@@Z ; Logger::Logger
; File D:\paste\OTC\headers\runtime\RuntimeHandler.h

; 9    :     RuntimeHandler (Segment& segment) : m_Segment (segment) {};

  000d2	8d 45 90	 lea	 eax, DWORD PTR _segment$39[ebp]
  000d5	89 85 70 fe ff
	ff		 mov	 DWORD PTR _runtime$36[ebp], eax
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 4    :     if (variable && value) {

  000db	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  000de	85 c0		 test	 eax, eax
  000e0	0f 84 27 05 00
	00		 je	 $LN81@DllMain

; 5    :         *variable = value;

  000e6	a3 00 00 00 00	 mov	 DWORD PTR ?UnsafeLibraryPointer@Segment@@2KA, eax ; Segment::UnsafeLibraryPointer
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  000eb	8b 45 dc	 mov	 eax, DWORD PTR _logger$40[ebp+20]
  000ee	83 e8 00	 sub	 eax, 0
  000f1	74 23		 je	 SHORT $LN87@DllMain
  000f3	83 e8 01	 sub	 eax, 1
  000f6	75 37		 jne	 SHORT $LN92@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  000f8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  000fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00102	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00107	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0010c	8b c8		 mov	 ecx, eax
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00114	eb 19		 jmp	 SHORT $LN92@DllMain
$LN87@DllMain:

; 18   : 
; 19   : 	    case CONSOLE:
; 20   : 		   m_Game.PrintNewLineToConsole (count);

  00116	8b 7d c8	 mov	 edi, DWORD PTR _logger$40[ebp]
  00119	be 02 00 00 00	 mov	 esi, 2
  0011e	66 90		 npad	 2
$LL93@DllMain:
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00125	ff d7		 call	 edi
  00127	83 c4 04	 add	 esp, 4
  0012a	83 ee 01	 sub	 esi, 1
  0012d	75 f1		 jne	 SHORT $LL93@DllMain
$LN92@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 39   :         logger.Info ("| [~] Performing basic checks...");

  0012f	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File D:\paste\OTC\cpp\utils\Utils.cpp

; 137  :     ZeroMemory (&osVersionInfo, sizeof (OSVERSIONINFO));

  0013d	68 14 01 00 00	 push	 276			; 00000114H
  00142	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$38[ebp]
  00148	6a 00		 push	 0
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _memset

; 138  : 
; 139  :     //This causes a little confused. 
; 140  :     //
; 141  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 142  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong. 
; 143  :     if (GetVersionEx (&osVersionInfo)) return true;

  00150	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetVersionExW@4
  00156	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$38[ebp]
  0015c	83 c4 14	 add	 esp, 20			; 00000014H
  0015f	50		 push	 eax
  00160	ff d6		 call	 esi
  00162	85 c0		 test	 eax, eax
  00164	0f 85 6e 04 00
	00		 jne	 $LN4@DllMain

; 144  : 
; 145  :     return ((osVersionInfo.dwMajorVersion > 5) || ((osVersionInfo.dwMajorVersion == 5) && (osVersionInfo.dwMinorVersion >= 1)));

  0016a	83 bd 80 fe ff
	ff 05		 cmp	 DWORD PTR _osVersionInfo$38[ebp+4], 5
  00171	0f 87 61 04 00
	00		 ja	 $LN4@DllMain
  00177	75 0d		 jne	 SHORT $LN290@DllMain
  00179	83 bd 84 fe ff
	ff 01		 cmp	 DWORD PTR _osVersionInfo$38[ebp+8], 1
  00180	0f 83 52 04 00
	00		 jae	 $LN4@DllMain
$LN290@DllMain:

; 152  :     ZeroMemory (&osVersionInfo, sizeof(OSVERSIONINFO));

  00186	68 14 01 00 00	 push	 276			; 00000114H
  0018b	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$37[ebp]
  00191	6a 00		 push	 0
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _memset
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 
; 154  :     //This causes a little confused. 
; 155  :     //
; 156  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 157  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong.
; 158  :     if (GetVersionEx ((LPOSVERSIONINFO) &osVersionInfo)) return true;

  0019c	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$37[ebp]
  001a2	50		 push	 eax
  001a3	ff d6		 call	 esi
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 2b 04 00
	00		 jne	 $LN4@DllMain
; File D:\paste\OTC\dllmain.cpp

; 42   :         if (Utils::IsWinXPOrLater () || Utils::IsWinServBuild ()) {

  001ad	80 7d 8e 01	 cmp	 BYTE PTR _osVersionInfo$37[ebp+282], 1
  001b1	0f 84 21 04 00
	00		 je	 $LN4@DllMain

; 45   :            return FALSE;
; 46   :         }
; 47   : 
; 48   :         logger.Info ("| [+] Your windows version meets the requirements for running OTC.");

  001b7	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  001c5	83 c4 08	 add	 esp, 8

; 49   :         
; 50   :         //Pretty common issue.
; 51   :         if (!Utils::IsRedistPackagePresent ()) {

  001c8	e8 00 00 00 00	 call	 ?IsRedistPackagePresent@Utils@@SA_NXZ ; Utils::IsRedistPackagePresent
  001cd	84 c0		 test	 al, al
  001cf	75 0f		 jne	 SHORT $LN5@DllMain

; 52   :             logger.Info ("| [!] Could not find the msvc redist package installed on your system.");
; 53   :             logger.Info ("| [~] You can download and install the redist build from here: https://www.microsoft.com/en-us/download/confirmation.aspx?id=52685.");
; 54   :             return FALSE;

  001d1	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@
  001d6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EH@CFBGKODN@?$HM?5?$FL?$CB?$FN?5Could?5not?5find?5the?5msvc?5r@
  001db	e9 02 04 00 00	 jmp	 $LN14@DllMain
$LN5@DllMain:

; 55   :         }
; 56   : 
; 57   :         logger.Info ("| [+] Found the required msvc redist build on your system.");

  001e0	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info

; 58   :         logger.Info ("| [+] All checks passed.");

  001ee	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  001fc	8b 45 dc	 mov	 eax, DWORD PTR _logger$40[ebp+20]
; File D:\paste\OTC\dllmain.cpp

; 58   :         logger.Info ("| [+] All checks passed.");

  001ff	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00202	83 e8 00	 sub	 eax, 0
  00205	74 23		 je	 SHORT $LN113@DllMain
  00207	83 e8 01	 sub	 eax, 1
  0020a	75 29		 jne	 SHORT $LN118@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  0020c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00211	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00216	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0021b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00220	8b c8		 mov	 ecx, eax
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00228	eb 0b		 jmp	 SHORT $LN118@DllMain
$LN113@DllMain:
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0022f	ff 55 c8	 call	 DWORD PTR _logger$40[ebp]
  00232	83 c4 04	 add	 esp, 4
$LN118@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 62   :         logger.Info ("| [~] Extracting segment to memory....");

  00235	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  00243	83 c4 08	 add	 esp, 8
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp

; 5    :     PanicUtils::SetImportant (&Segment::UnsafeAllocatedPointer, reinterpret_cast<DWORD> (VirtualAlloc (NULL, SegmentHeader::Datacase::ALLOCATION, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)));

  00246	6a 40		 push	 64			; 00000040H
  00248	68 00 30 00 00	 push	 12288			; 00003000H
  0024d	68 40 89 96 00	 push	 9865536			; 00968940H
  00252	6a 00		 push	 0
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 4    :     if (variable && value) {

  0025a	85 c0		 test	 eax, eax
  0025c	0f 84 ab 03 00
	00		 je	 $LN81@DllMain
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  00262	68 00 6a 18 00	 push	 1600000			; 00186a00H
  00267	68 00 00 00 00	 push	 OFFSET ?SegmentData@@3QBEB ; SegmentData
  0026c	50		 push	 eax
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 5    :         *variable = value;

  0026d	a3 00 00 00 00	 mov	 DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA, eax ; Segment::UnsafeAllocatedPointer
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  00272	e8 00 00 00 00	 call	 _memcpy
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0027a	85 c0		 test	 eax, eax
  0027c	0f 84 9a 03 00
	00		 je	 $LN295@DllMain
; File D:\paste\OTC\dllmain.cpp

; 66   :         logger.Info ("| [~] Reconstructing hot-points...");

  00282	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  00285	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@
  0028a	50		 push	 eax
  0028b	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  00290	83 c4 08	 add	 esp, 8

; 67   : 
; 68   :         runtime.ReconstructHotPoints ();

  00293	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _runtime$36[ebp]
  00299	e8 00 00 00 00	 call	 ?ReconstructHotPoints@RuntimeHandler@@QAEXXZ ; RuntimeHandler::ReconstructHotPoints

; 70   :         logger.Info ("| [+] Wait until the framework complete routine work...");

  0029e	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CFAIMOHN@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5framework?5@
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  002ac	8b 45 dc	 mov	 eax, DWORD PTR _logger$40[ebp+20]
; File D:\paste\OTC\dllmain.cpp

; 70   :         logger.Info ("| [+] Wait until the framework complete routine work...");

  002af	83 c4 08	 add	 esp, 8
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  002b2	83 e8 00	 sub	 eax, 0
  002b5	74 23		 je	 SHORT $LN140@DllMain
  002b7	83 e8 01	 sub	 eax, 1
  002ba	75 29		 jne	 SHORT $LN145@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  002bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  002c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  002c6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002cb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002d0	8b c8		 mov	 ecx, eax
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002d8	eb 0b		 jmp	 SHORT $LN145@DllMain
$LN140@DllMain:
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  002da	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  002df	ff 55 c8	 call	 DWORD PTR _logger$40[ebp]
  002e2	83 c4 04	 add	 esp, 4
$LN145@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 74   :         logger.Info ("| [~] Filling the dependency table... (~7-15 sec)");

  002e5	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  002e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MPINGACN@?$HM?5?$FL?$HO?$FN?5Filling?5the?5dependency?5ta@
  002ed	50		 push	 eax
  002ee	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  002f3	83 c4 08	 add	 esp, 8

; 75   : 
; 76   :         segment.GetFramework().CreateDependencyTable ();

  002f6	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  002fc	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  00305	8b c8		 mov	 ecx, eax
  00307	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0030b	e8 00 00 00 00	 call	 ?CreateDependencyTable@SegmentFramework@@QAEXXZ ; SegmentFramework::CreateDependencyTable
  00310	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00316	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0031a	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 77   : 
; 78   :         logger.Info ("| [~] Updating netvars...");

  0031f	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JDCGCNGO@?$HM?5?$FL?$HO?$FN?5Updating?5netvars?4?4?4@
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0032d	83 c4 08	 add	 esp, 8

; 80   :         segment.GetFramework().UpdateNetVars ();

  00330	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00336	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  0033f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 54   :     for (const auto& netvar : m_netvars) {

  00343	8b 08		 mov	 ecx, DWORD PTR [eax]
  00345	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00348	3b cf		 cmp	 ecx, edi
  0034a	74 21		 je	 SHORT $LN150@DllMain
  0034c	0f 1f 40 00	 npad	 4
$LL151@DllMain:
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00350	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 55   :         *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer () + netvar.rva) = netvar.new_value;

  00356	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00359	85 d2		 test	 edx, edx
  0035b	0f 84 c7 02 00
	00		 je	 $LN265@DllMain
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 54   :     for (const auto& netvar : m_netvars) {

  00361	8b 01		 mov	 eax, DWORD PTR [ecx]
  00363	83 c1 08	 add	 ecx, 8

; 55   :         *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer () + netvar.rva) = netvar.new_value;

  00366	89 34 02	 mov	 DWORD PTR [edx+eax], esi
  00369	3b cf		 cmp	 ecx, edi
  0036b	75 e3		 jne	 SHORT $LL151@DllMain
$LN150@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 80   :         segment.GetFramework().UpdateNetVars ();

  0036d	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00373	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00377	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 81   : 
; 82   :         logger.Info ("| [~] Install hook for virtual function caller...");

  0037c	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@FNBEDFB@?$HM?5?$FL?$HO?$FN?5Install?5hook?5for?5virtual?5@
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0038a	83 c4 08	 add	 esp, 8

; 84   :         segment.GetFramework().InstallHook ();

  0038d	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  00393	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00396	50		 push	 eax
  00397	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  0039c	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  003a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  003a6	85 c9		 test	 ecx, ecx
  003a8	0f 84 7a 02 00
	00		 je	 $LN265@DllMain
; File D:\otc-priv\OTC\libs\libs\HookLib\HookLib\HookLib\HookLib.c

  003ae	51		 push	 ecx
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 77   :       SetHook (reinterpret_cast <PVOID> (Segment::GetSafeAllocationPointer () + Datacase::VIRTUAL_EXECUTOR_RVA), &CustomVirtualCaller, reinterpret_cast<PVOID*> (&OriginalVirtualCaller));                               //

  003af	81 c1 30 3b 00
	00		 add	 ecx, 15152		; 00003b30H
; File D:\otc-priv\OTC\libs\libs\HookLib\HookLib\HookLib\HookLib.c

  003b5	e8 00 00 00 00	 call	 _SetHookUm
  003ba	83 c4 04	 add	 esp, 4
; File D:\paste\OTC\dllmain.cpp

; 84   :         segment.GetFramework().InstallHook ();

  003bd	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  003c1	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  003c7	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 85   : 
; 86   :         logger.Info ("| [~] Updating watermark...");

  003cc	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  003cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FALAIJHL@?$HM?5?$FL?$HO?$FN?5Updating?5watermark?4?4?4@
  003d4	50		 push	 eax
  003d5	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  003da	83 c4 08	 add	 esp, 8

; 88   :         segment.GetFramework().UpdateWatermark (" ☁ ", " ☁ ");

  003dd	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  003e3	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 116  :        std::strncpy (watermark, mark, 16);                                                                                                                       //

  003ec	6a 10		 push	 16			; 00000010H
  003ee	8d 45 e0	 lea	 eax, DWORD PTR _watermark$41[ebp]
; File D:\paste\OTC\dllmain.cpp

; 88   :         segment.GetFramework().UpdateWatermark (" ☁ ", " ☁ ");

  003f1	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 116  :        std::strncpy (watermark, mark, 16);                                                                                                                       //

  003f5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__strncpy
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_03MEDKAJNC@?5?$DP?5@
  00400	50		 push	 eax
  00401	ff d7		 call	 edi
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00403	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 116  :        std::strncpy (watermark, mark, 16);                                                                                                                       //

  00409	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0040c	85 d2		 test	 edx, edx
  0040e	0f 84 14 02 00
	00		 je	 $LN265@DllMain
; File D:\paste\OTC\headers\segment\Segment.h

; 25   : 		return UnsafeAllocatedPointer;

  00414	8d 4d e0	 lea	 ecx, DWORD PTR _watermark$41[ebp]
  00417	81 c2 81 d3 12
	00		 add	 edx, 1233793		; 0012d381H
  0041d	be 04 00 00 00	 mov	 esi, 4
$LL183@DllMain:
; File D:\paste\OTC\cpp\utils\Utils.cpp

; 126  :         std::memcpy (reinterpret_cast <DWORD*> (base + offsetToInstructions + instructionsIterator), compressedArray + segmentedCharIterator, instructionCharMoveCount);

  00422	8b 01		 mov	 eax, DWORD PTR [ecx]

; 127  :         segmentedCharIterator += arrayCharCycleUpdate;

  00424	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00427	89 02		 mov	 DWORD PTR [edx], eax
  00429	8d 52 07	 lea	 edx, DWORD PTR [edx+7]
  0042c	83 ee 01	 sub	 esi, 1
  0042f	75 f1		 jne	 SHORT $LL183@DllMain
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00431	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00436	85 c0		 test	 eax, eax
  00438	0f 84 ea 01 00
	00		 je	 $LN265@DllMain
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 130  :        std::memmove (reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer() + 0x1), player, 0x20);                                                        //

  0043e	6a 20		 push	 32			; 00000020H
  00440	40		 inc	 eax
  00441	68 00 00 00 00	 push	 OFFSET ??_C@_03MEDKAJNC@?5?$DP?5@
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 _memmove
  0044c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\paste\OTC\dllmain.cpp

; 88   :         segment.GetFramework().UpdateWatermark (" ☁ ", " ☁ ");

  0044f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00453	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00459	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 89   :         segment.GetFramework().UpdateMenuWatermark (" ☁ ");

  0045e	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  00464	50		 push	 eax
  00465	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00468	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 148  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  0046d	6a 0c		 push	 12			; 0000000cH
  0046f	8d 45 e4	 lea	 eax, DWORD PTR _watermark$42[ebp]
; File D:\paste\OTC\dllmain.cpp

; 89   :         segment.GetFramework().UpdateMenuWatermark (" ☁ ");

  00472	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 148  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  00476	68 00 00 00 00	 push	 OFFSET ??_C@_03MEDKAJNC@?5?$DP?5@
  0047b	50		 push	 eax
  0047c	ff d7		 call	 edi
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0047e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 148  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  00484	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00487	85 d2		 test	 edx, edx
  00489	0f 84 a8 01 00
	00		 je	 $LN296@DllMain
; File D:\paste\OTC\headers\segment\Segment.h

; 25   : 		return UnsafeAllocatedPointer;

  0048f	8d 4d e4	 lea	 ecx, DWORD PTR _watermark$42[ebp]
  00492	81 c2 5f 02 0e
	00		 add	 edx, 918111		; 000e025fH
  00498	be 03 00 00 00	 mov	 esi, 3
  0049d	0f 1f 00	 npad	 3
$LL203@DllMain:
; File D:\paste\OTC\cpp\utils\Utils.cpp

; 126  :         std::memcpy (reinterpret_cast <DWORD*> (base + offsetToInstructions + instructionsIterator), compressedArray + segmentedCharIterator, instructionCharMoveCount);

  004a0	8b 01		 mov	 eax, DWORD PTR [ecx]

; 127  :         segmentedCharIterator += arrayCharCycleUpdate;

  004a2	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  004a5	89 02		 mov	 DWORD PTR [edx], eax
  004a7	8d 52 07	 lea	 edx, DWORD PTR [edx+7]
  004aa	83 ee 01	 sub	 esi, 1
  004ad	75 f1		 jne	 SHORT $LL203@DllMain
; File D:\paste\OTC\dllmain.cpp

; 89   :         segment.GetFramework().UpdateMenuWatermark (" ☁ ");

  004af	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  004b5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004b9	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  004be	8b 45 dc	 mov	 eax, DWORD PTR _logger$40[ebp+20]
  004c1	2b c6		 sub	 eax, esi
  004c3	74 23		 je	 SHORT $LN208@DllMain
  004c5	83 e8 01	 sub	 eax, 1
  004c8	75 29		 jne	 SHORT $LN213@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  004ca	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  004cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  004d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004d9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004de	8b c8		 mov	 ecx, eax
  004e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  004e6	eb 0b		 jmp	 SHORT $LN213@DllMain
$LN208@DllMain:
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  004e8	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  004ed	ff 55 c8	 call	 DWORD PTR _logger$40[ebp]
  004f0	83 c4 04	 add	 esp, 4
$LN213@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 93   :         logger.Info ("| [~] Invoking OEP...");

  004f3	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DLJKLACG@?$HM?5?$FL?$HO?$FN?5Invoking?5OEP?4?4?4@
  004fb	50		 push	 eax
  004fc	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00501	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File D:\paste\OTC\dllmain.cpp

; 93   :         logger.Info ("| [~] Invoking OEP...");

  00506	83 c4 08	 add	 esp, 8
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00509	85 c0		 test	 eax, eax
  0050b	0f 84 35 01 00
	00		 je	 $LN297@DllMain
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp

; 81   :     SegmentHeader::DLLMAIN_CALLBACK DllMain = reinterpret_cast <SegmentHeader::DLLMAIN_CALLBACK> (Segment::GetSafeAllocationPointer() + SegmentHeader::Datacase::OEP);

  00511	8d 88 8c 73 04
	00		 lea	 ecx, DWORD PTR [eax+291724]
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00517	85 c9		 test	 ecx, ecx
  00519	0f 84 36 01 00
	00		 je	 $LN298@DllMain
; File D:\paste\OTC\cpp\runtime\RuntimeHandler.cpp

; 85   :     DllMain (reinterpret_cast<HMODULE> (Segment::GetSafeAllocationPointer()), DLL_PROCESS_ATTACH, NULL);

  0051f	6a 00		 push	 0
  00521	6a 01		 push	 1
  00523	50		 push	 eax
  00524	ff d1		 call	 ecx
; File D:\paste\OTC\dllmain.cpp

; 99   :         segment.GetFramework().SetMenuStatus (false);

  00526	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  0052c	50		 push	 eax
  0052d	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00530	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  00535	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00539	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  0053e	85 c0		 test	 eax, eax
  00540	0f 84 1b 01 00
	00		 je	 $LN299@DllMain
; File D:\paste\OTC\dllmain.cpp

; 99   :         segment.GetFramework().SetMenuStatus (false);

  00546	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
; File D:\paste\OTC\cpp\frameworks\SegmentFramework.cpp

; 161  :     *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer() + Datacase::MENU_STATUS_RVA) = status;

  0054c	c7 80 67 5f 48
	00 00 00 00 00	 mov	 DWORD PTR [eax+4743015], 0
; File D:\paste\OTC\dllmain.cpp

; 99   :         segment.GetFramework().SetMenuStatus (false);

  00556	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0055a	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 101  :         logger.Info ("| [+] All loader procedures finished. Gl.");

  0055f	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  00562	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CANJDOLL@?$HM?5?$FL?$CL?$FN?5All?5loader?5procedures?5fin@
  00567	50		 push	 eax
  00568	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  0056d	8b 45 dc	 mov	 eax, DWORD PTR _logger$40[ebp+20]
; File D:\paste\OTC\dllmain.cpp

; 101  :         logger.Info ("| [+] All loader procedures finished. Gl.");

  00570	83 c4 08	 add	 esp, 8
; File D:\paste\OTC\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00573	83 e8 00	 sub	 eax, 0
  00576	74 23		 je	 SHORT $LN246@DllMain
  00578	83 e8 01	 sub	 eax, 1
  0057b	75 29		 jne	 SHORT $LN251@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  0057d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00582	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00587	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0058c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00591	8b c8		 mov	 ecx, eax
  00593	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00599	eb 0b		 jmp	 SHORT $LN251@DllMain
$LN246@DllMain:
; File D:\paste\OTC\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  0059b	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  005a0	ff 55 c8	 call	 DWORD PTR _logger$40[ebp]
  005a3	83 c4 04	 add	 esp, 4
$LN251@DllMain:
  005a6	8d 4d a4	 lea	 ecx, DWORD PTR _segment$39[ebp+20]
  005a9	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  005ae	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  005b1	e8 00 00 00 00	 call	 ??1SegmentHeader@@QAE@XZ
$LN255@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 107  :     return TRUE;

  005b6	b8 01 00 00 00	 mov	 eax, 1
$LN1@DllMain:

; 109  : }

  005bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005c5	59		 pop	 ecx
  005c6	5f		 pop	 edi
  005c7	5e		 pop	 esi
  005c8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005cb	33 cd		 xor	 ecx, ebp
  005cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d2	8b e5		 mov	 esp, ebp
  005d4	5d		 pop	 ebp
  005d5	c2 0c 00	 ret	 12			; 0000000cH
$LN4@DllMain:

; 43   :            logger.Info ("| [-] I cannot run OTC on the current version of Windows.");
; 44   :            logger.Info ("| [~] Please upgrade to 7 or 8, or 10. (PC build)");

  005d8	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@
  005dd	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@
$LN14@DllMain:

; 52   :             logger.Info ("| [!] Could not find the msvc redist package installed on your system.");
; 53   :             logger.Info ("| [~] You can download and install the redist build from here: https://www.microsoft.com/en-us/download/confirmation.aspx?id=52685.");
; 54   :             return FALSE;

  005e2	50		 push	 eax
  005e3	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  005e6	50		 push	 eax
  005e7	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  005ec	8d 45 c8	 lea	 eax, DWORD PTR _logger$40[ebp]
  005ef	56		 push	 esi
  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  005f6	83 c4 10	 add	 esp, 16			; 00000010H
  005f9	8d 4d a4	 lea	 ecx, DWORD PTR _segment$39[ebp+20]
  005fc	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  00601	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00604	e8 00 00 00 00	 call	 ??1SegmentHeader@@QAE@XZ
  00609	33 c0		 xor	 eax, eax
  0060b	eb ae		 jmp	 SHORT $LN1@DllMain
$LN81@DllMain:
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 8    :         PanicUtils::Release (Layers::ROUTINE, reason);

  0060d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@
  00612	b9 01 00 00 00	 mov	 ecx, 1
  00617	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN295@DllMain:

; 14   :         PanicUtils::Release (layer, reason);

  0061c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@
  00621	33 c9		 xor	 ecx, ecx
  00623	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN265@DllMain:
; File D:\paste\OTC\dllmain.cpp

; 109  : }

  00628	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  0062d	b9 01 00 00 00	 mov	 ecx, 1
  00632	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN296@DllMain:
; File D:\paste\OTC\cpp\utils\PanicUtils.cpp

; 14   :         PanicUtils::Release (layer, reason);

  00637	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  0063c	b9 01 00 00 00	 mov	 ecx, 1
  00641	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN297@DllMain:
  00646	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  0064b	b9 01 00 00 00	 mov	 ecx, 1
  00650	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN298@DllMain:
  00655	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@
  0065a	33 c9		 xor	 ecx, ecx
  0065c	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN299@DllMain:
  00661	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  00666	b9 01 00 00 00	 mov	 ecx, 1
  0066b	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN293@DllMain:
  00670	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DllMain@12$9:
  00000	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$_DllMain@12$10:
  0000b	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 08	 add	 ecx, 8
  00014	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$_DllMain@12$7:
  00019	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
__unwindfunclet$_DllMain@12$0:
  00021	8d 4d 90	 lea	 ecx, DWORD PTR _segment$39[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1Segment@@QAE@XZ
__unwindfunclet$_DllMain@12$1:
  00029	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$2:
  00034	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$3:
  0003f	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$4:
  0004a	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$5:
  00055	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$6:
  00060	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  00066	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
__ehhandler$_DllMain@12:
  00070	90		 npad	 1
  00071	90		 npad	 1
  00072	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00076	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00079	8b 8a 48 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-440]
  0007f	33 c8		 xor	 ecx, eax
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00089	33 c8		 xor	 ecx, eax
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DllMain@12
  00095	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DllMain@12 ENDP
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File D:\paste\OTC\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File D:\paste\OTC\headers\segment\SegmentHeader.h
;	COMDAT ??0Segment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Segment@@QAE@XZ PROC					; Segment::Segment, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Segment@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002b	6a 20		 push	 32			; 00000020H
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00036	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00045	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00047	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0004a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0004d	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00053	89 06		 mov	 DWORD PTR [esi], eax
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00063	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0006a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\paste\OTC\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  00071	8b ce		 mov	 ecx, esi
  00073	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00077	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations
  00083	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00086	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008d	e8 00 00 00 00	 call	 ??0SegmentFramework@@QAE@XZ
  00092	8b c6		 mov	 eax, esi
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00097	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009e	59		 pop	 ecx
  0009f	5e		 pop	 esi
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Segment@@QAE@XZ$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0Segment@@QAE@XZ$3:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0Segment@@QAE@XZ$0:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$??0Segment@@QAE@XZ:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Segment@@QAE@XZ
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Segment@@QAE@XZ ENDP					; Segment::Segment
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0SegmentFramework@@QAE@XZ
_TEXT	SEGMENT
_this$GSCopy$ = -384					; size = 4
$T21 = -380						; size = 344
$T17 = -36						; size = 16
$T3 = -20						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SegmentFramework@@QAE@XZ PROC			; SegmentFramework::SegmentFramework, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentFramework@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  0002f	89 bd 80 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1663 :         _Buy_raw(_Newcapacity);

  00035	6a 01		 push	 1
  00037	c7 45 ec 50 a2
	95 00		 mov	 DWORD PTR $T3[ebp], 9806416 ; 0095a250H
  0003e	c7 45 f0 28 39
	00 00		 mov	 DWORD PTR $T3[ebp+4], 14632 ; 00003928H

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00045	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0004b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00052	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1663 :         _Buy_raw(_Newcapacity);

  00059	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0005e	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00060	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00063	6a 08		 push	 8
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0006c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0006f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00072	83 c4 08	 add	 esp, 8
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  0007c	8d 45 ec	 lea	 eax, DWORD PTR $T17[ebp+16]
  0007f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T17[ebp], OFFSET ??_C@_0L@PHFEFMEF@client?4dll@
  00086	8d 55 dc	 lea	 edx, DWORD PTR $T17[ebp]
  00089	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+4], OFFSET ??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@
  00090	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00093	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+8], OFFSET ??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@
  0009a	50		 push	 eax
  0009b	52		 push	 edx
  0009c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+12], OFFSET ??_C@_0M@EINGCJHB@vstdlib?4dll@
  000a3	e8 00 00 00 00	 call	 ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
  000a8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ac	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp], OFFSET ??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@
  000b6	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+4], OFFSET ??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@
  000c0	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+8], OFFSET ??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@
  000ca	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+12], OFFSET ??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@
  000d4	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+16], OFFSET ??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@
  000de	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+20], OFFSET ??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@
  000e8	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+24], OFFSET ??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@
  000f2	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+28], OFFSET ??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@
  000fc	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+32], OFFSET ??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@
  00106	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+36], OFFSET ??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
  00110	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+40], OFFSET ??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@
  0011a	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+44], OFFSET ??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@
  00124	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+48], OFFSET ??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@
  0012e	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+52], OFFSET ??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@
  00138	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+56], OFFSET ??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@
  00142	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+60], OFFSET ??_C@_0M@MACNFAAE@B0?501?583?5FE@
  0014c	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+64], OFFSET ??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@
  00156	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+68], OFFSET ??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@
  00160	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+72], OFFSET ??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@
  0016a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+76], OFFSET ??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@
  00174	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+80], OFFSET ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
  0017e	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+84], OFFSET ??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@
  00188	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+88], OFFSET ??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@
  00192	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+92], OFFSET ??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@
  0019c	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+96], OFFSET ??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@
  001a6	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+100], OFFSET ??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@
  001b0	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+104], OFFSET ??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@
  001ba	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+108], OFFSET ??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@
  001c4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+112], OFFSET ??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@
  001ce	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+116], OFFSET ??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@
  001d8	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+120], OFFSET ??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@
  001e2	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+124], OFFSET ??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@
  001ec	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+128], OFFSET ??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@
  001f6	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+132], OFFSET ??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@
  00200	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+136], OFFSET ??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@
  0020a	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+140], OFFSET ??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@
  00214	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+144], OFFSET ??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@
  0021e	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+148], OFFSET ??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@
  00228	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+152], OFFSET ??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@
  00232	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+156], OFFSET ??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@
  0023c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+160], OFFSET ??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@
  00246	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+164], OFFSET ??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@
  00250	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+168], OFFSET ??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@
  0025a	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+172], OFFSET ??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@
  00264	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+176], OFFSET ??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@
  0026e	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+180], OFFSET ??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@
  00278	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+184], OFFSET ??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@
  00282	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+188], OFFSET ??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@
  0028c	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+192], OFFSET ??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@
  00296	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+196], OFFSET ??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@
  002a0	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  002a6	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+200], OFFSET ??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@
  002b0	51		 push	 ecx
  002b1	8d 45 dc	 lea	 eax, DWORD PTR $T21[ebp+344]
  002b4	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+204], OFFSET ??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@
  002be	50		 push	 eax
  002bf	51		 push	 ecx
  002c0	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  002c3	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+208], OFFSET ??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@
  002cd	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+212], OFFSET ??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@
  002d7	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+216], OFFSET ??_C@_0P@CGNIIJII@75?504?5B0?501?55F@
  002e1	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+220], OFFSET ??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@
  002eb	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+224], OFFSET ??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@
  002f5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+228], OFFSET ??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@
  002ff	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+232], OFFSET ??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@
  00309	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+236], OFFSET ??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@
  00313	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+240], OFFSET ??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@
  0031d	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+244], OFFSET ??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@
  00327	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+248], OFFSET ??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@
  00331	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+252], OFFSET ??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@
  00338	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+256], OFFSET ??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@
  0033f	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+260], OFFSET ??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@
  00346	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+264], OFFSET ??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@
  0034d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+268], OFFSET ??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@
  00354	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+272], OFFSET ??_C@_0M@OEHPONHC@75?54B?50F?557@
  0035b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+276], OFFSET ??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@
  00362	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+280], OFFSET ??_C@_0M@OFBMICFD@56?58D?551?53C@
  00369	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+284], OFFSET ??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@
  00370	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+288], OFFSET ??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
  00377	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+292], OFFSET ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
  0037e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+296], OFFSET ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
  00385	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+300], OFFSET ??_C@_0M@GHAFGLNO@8D?54E?574?58B@
  0038c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+304], OFFSET ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
  00393	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+308], OFFSET ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
  0039a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+312], OFFSET ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
  003a1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+316], OFFSET ??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@
  003a8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+320], OFFSET ??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@
  003af	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+324], OFFSET ??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@
  003b6	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+328], OFFSET ??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@
  003bd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+332], OFFSET ??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@
  003c4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+336], OFFSET ??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@
  003cb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+340], OFFSET ??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@
  003d2	e8 00 00 00 00	 call	 ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
  003d7	8b c7		 mov	 eax, edi
  003d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003e3	59		 pop	 ecx
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentFramework@@QAE@XZ$0:
  00000	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$??0SegmentFramework@@QAE@XZ$1:
  0000b	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$??0SegmentFramework@@QAE@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 8a 80 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-384]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentFramework@@QAE@XZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentFramework@@QAE@XZ ENDP			; SegmentFramework::SegmentFramework
; Function compile flags: /Ogtp
;	COMDAT ??1Segment@@QAE@XZ
_TEXT	SEGMENT
??1Segment@@QAE@XZ PROC					; Segment::~Segment, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00006	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  0000b	8b ce		 mov	 ecx, esi
  0000d	5e		 pop	 esi
  0000e	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
??1Segment@@QAE@XZ ENDP					; Segment::~Segment
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@Segment@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@Segment@@QAEXI@Z PROC			; Segment::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	6a 38		 push	 56			; 00000038H
  00002	6a 00		 push	 0
  00004	51		 push	 ecx
  00005	e8 00 00 00 00	 call	 _memset
  0000a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0000d	c2 04 00	 ret	 4
?__autoclassinit2@Segment@@QAEXI@Z ENDP			; Segment::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z PROC	; std::initializer_list<char const *>::initializer_list<char const *>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z ENDP	; std::initializer_list<char const *>::initializer_list<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
$T12 = -4						; size = 4
__Ilist$ = 8						; size = 8
__Al$dead$ = 16						; size = 4
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >, COMDAT
; _this$ = ecx

; 512  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ilist$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Ilist$[ebp+4]
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 7d fc	 mov	 DWORD PTR $T12[ebp], edi
  00013	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00015	c1 ff 02	 sar	 edi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00018	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00021	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00028	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 493  :         if (_Count != 0) {

  0002f	85 ff		 test	 edi, edi
  00031	74 2b		 je	 SHORT $LN27@vector

; 1659 :         if (_Newcapacity > max_size()) {

  00033	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00039	77 2d		 ja	 SHORT $LN51@vector
  0003b	56		 push	 esi

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00042	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00048	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004a	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _memmove
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00057	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0005a	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0005d	5e		 pop	 esi
$LN27@vector:

; 516  :         _Proxy._Release();
; 517  :     }

  0005e	5f		 pop	 edi
  0005f	8b c3		 mov	 eax, ebx
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN51@vector:

; 1660 :             _Xlength();

  00068	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN49@vector:
  0006d	cc		 int	 3
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@PBD@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PBD@std@@QAE@XZ PROC			; std::allocator<char const *>::allocator<char const *>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PBD@std@@QAE@XZ ENDP			; std::allocator<char const *>::allocator<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 678  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN25@vector:
  00051	cc		 int	 3
??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightfirst$1$ = -8					; size = 4
__Rightlast$1$ = -4					; size = 4
__Right$ = 8						; size = 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 519  :     vector(const vector& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00019	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00020	8b 08		 mov	 ecx, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00022	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00025	89 4d f8	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00028	3b c8		 cmp	 ecx, eax
  0002a	74 2d		 je	 SHORT $LN41@vector

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0002c	56		 push	 esi
  0002d	2b c1		 sub	 eax, ecx
  0002f	8b cb		 mov	 ecx, ebx
  00031	57		 push	 edi
  00032	8b f8		 mov	 edi, eax
  00034	89 45 fc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00037	c1 ff 03	 sar	 edi, 3
  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00040	ff 75 fc	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00043	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00045	ff 75 f8	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00051	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00054	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 531  :             _Guard._Target   = nullptr;
; 532  :         }
; 533  : 
; 534  :         _Proxy._Release();
; 535  :     }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
$LN41@vector:
  00059	8b c3		 mov	 eax, ebx
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
$T12 = -4						; size = 4
__Ilist$ = 8						; size = 8
__Al$dead$ = 16						; size = 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 512  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ilist$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Ilist$[ebp+4]
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 7d fc	 mov	 DWORD PTR $T12[ebp], edi
  00013	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00015	c1 ff 03	 sar	 edi, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00018	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00021	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00028	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 493  :         if (_Count != 0) {

  0002f	85 ff		 test	 edi, edi
  00031	74 2b		 je	 SHORT $LN27@vector

; 1659 :         if (_Newcapacity > max_size()) {

  00033	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00039	77 2d		 ja	 SHORT $LN51@vector
  0003b	56		 push	 esi

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00042	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00048	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004a	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _memmove
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00057	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0005a	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0005d	5e		 pop	 esi
$LN27@vector:

; 516  :         _Proxy._Release();
; 517  :     }

  0005e	5f		 pop	 edi
  0005f	8b c3		 mov	 eax, ebx
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN51@vector:

; 1660 :             _Xlength();

  00068	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN49@vector:
  0006d	cc		 int	 3
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00007	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00026	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00029	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0002f	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >, COMDAT
; _this$ = ecx

; 5692 :     ~_Tidy_guard() {

  00000	56		 push	 esi

; 5693 :         if (_Target) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 46		 je	 SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 40		 je	 SHORT $LN5@Tidy_guard

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00010	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN21@Tidy_guard

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN18@Tidy_guard

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN21@Tidy_guard:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00046	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
  0004d	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 5696 :     }

  0004e	c3		 ret	 0
$LN18@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN26@Tidy_guard:
  00055	cc		 int	 3
??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?end@?$initializer_list@PBD@std@@QBEPBQBDXZ
_TEXT	SEGMENT
?end@?$initializer_list@PBD@std@@QBEPBQBDXZ PROC	; std::initializer_list<char const *>::end, COMDAT
; _this$ = ecx

; 43   :         return _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 44   :     }

  00003	c3		 ret	 0
?end@?$initializer_list@PBD@std@@QBEPBQBDXZ ENDP	; std::initializer_list<char const *>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ
_TEXT	SEGMENT
?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ PROC	; std::initializer_list<char const *>::begin, COMDAT
; _this$ = ecx

; 39   :         return _First;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 40   :     }

  00002	c3		 ret	 0
?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ ENDP	; std::initializer_list<char const *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ
_TEXT	SEGMENT
?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end, COMDAT
; _this$ = ecx

; 43   :         return _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 44   :     }

  00003	c3		 ret	 0
?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ
_TEXT	SEGMENT
?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin, COMDAT
; _this$ = ecx

; 39   :         return _First;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 40   :     }

  00002	c3		 ret	 0
?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1737 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN18@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN15@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN18@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1701 :     }

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Tidy:
  00051	cc		 int	 3
?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  0000a	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00010	77 6f		 ja	 SHORT $LN30@Buy_raw

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00012	c1 e6 03	 shl	 esi, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0001b	72 35		 jb	 SHORT $LN10@Buy_raw

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001d	8d 46 23	 lea	 eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

  00020	3b c6		 cmp	 eax, esi
  00022	76 5d		 jbe	 SHORT $LN30@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002a	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0002c	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002f	85 c9		 test	 ecx, ecx
  00031	74 19		 je	 SHORT $LN19@Buy_raw

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00033	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00036	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00039	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0003c	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  0003e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00041	03 c6		 add	 eax, esi
  00043	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 1646 :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN19@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN10@Buy_raw:

; 179  :     if (_Bytes != 0) {

  00052	85 f6		 test	 esi, esi
  00054	74 19		 je	 SHORT $LN11@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0005c	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0005e	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1644 :         _Mylast            = _Newvec;

  00061	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00064	03 c6		 add	 eax, esi
  00066	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 1646 :     }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN11@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 183  :     return nullptr;

  0006f	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00071	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00076	8b c6		 mov	 eax, esi
  00078	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1646 :     }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN30@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00081	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN31@Buy_raw:
  00086	cc		 int	 3
?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >, COMDAT
; _this$ = ecx

; 880  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t(), _Parg, _Zero_then_variadic_args_t()) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00003	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00022	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00028	89 06		 mov	 DWORD PTR [esi], eax

; 881  :         _Alloc_sentinel_and_proxy();
; 882  :     }

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1733 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());
; 1613 :     }

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000b	77 4a		 ja	 SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000d	c1 e0 03	 shl	 eax, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00010	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00015	72 29		 jb	 SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00017	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  0001a	3b c8		 cmp	 ecx, eax
  0001c	76 39		 jbe	 SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00024	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  00026	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00029	85 c9		 test	 ecx, ecx
  0002b	74 0d		 je	 SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0002d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00030	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00033	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

  00040	85 c0		 test	 eax, eax
  00042	74 0d		 je	 SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004a	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN9@allocate:

; 183  :     return nullptr;

  00051	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00057	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN28@allocate:
  0005c	cc		 int	 3
?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00010	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00016	72 14		 jb	 SHORT $LN15@deallocate

; 108  :     _Bytes += _Non_user_size;

  00018	56		 push	 esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b ce		 sub	 ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 11		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b ce		 mov	 ecx, esi
  0002b	5e		 pop	 esi
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002c	52		 push	 edx
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00033	83 c4 08	 add	 esp, 8

; 781  :     }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00040	cc		 int	 3
?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00001	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000d	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00012	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00015	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2021 :         const auto _Scary = _Get_scary();
; 2022 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 2023 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	5e		 pop	 esi

; 2025 :         _Proxy._Release();
; 2026 :     }

  0001e	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -8					; size = 4
__First$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>, COMDAT
; _this$ = ecx

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  0000e	2b d8		 sub	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00010	89 45 fc	 mov	 DWORD PTR __First$GSCopy$1$[ebp], eax
  00013	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00014	8b fb		 mov	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00016	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00018	c1 ff 02	 sar	 edi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  0001b	89 75 f8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 492  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 493  :         if (_Count != 0) {

  0001e	85 ff		 test	 edi, edi
  00020	74 26		 je	 SHORT $LN21@Range_cons

; 1659 :         if (_Newcapacity > max_size()) {

  00022	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00028	77 27		 ja	 SHORT $LN44@Range_cons

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00030	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00032	53		 push	 ebx
  00033	ff 75 fc	 push	 DWORD PTR __First$GSCopy$1$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0003f	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00045	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Range_cons:

; 498  :             _Guard._Target   = nullptr;
; 499  :         }
; 500  :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN44@Range_cons:

; 1660 :             _Xlength();

  00051	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN42@Range_cons:
  00056	cc		 int	 3
??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 03	 sar	 edi, 3
  0001e	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -8					; size = 4
__First$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>, COMDAT
; _this$ = ecx

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  0000e	2b d8		 sub	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00010	89 45 fc	 mov	 DWORD PTR __First$GSCopy$1$[ebp], eax
  00013	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00014	8b fb		 mov	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00016	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00018	c1 ff 03	 sar	 edi, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  0001b	89 75 f8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 492  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 493  :         if (_Count != 0) {

  0001e	85 ff		 test	 edi, edi
  00020	74 26		 je	 SHORT $LN21@Range_cons

; 1659 :         if (_Newcapacity > max_size()) {

  00022	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00028	77 27		 ja	 SHORT $LN44@Range_cons

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00030	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00032	53		 push	 ebx
  00033	ff 75 fc	 push	 DWORD PTR __First$GSCopy$1$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0003f	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00045	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Range_cons:

; 498  :             _Guard._Target   = nullptr;
; 499  :         }
; 500  :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN44@Range_cons:

; 1660 :             _Xlength();

  00051	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN42@Range_cons:
  00056	cc		 int	 3
??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

  00000	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]

; 40   : }

  00013	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1648 :     void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 :         // allocate array with _Newcapacity elements
; 1650 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1651 :         auto& _My_data    = _Mypair._Myval2;
; 1652 :         pointer& _Myfirst = _My_data._Myfirst;
; 1653 :         pointer& _Mylast  = _My_data._Mylast;
; 1654 :         pointer& _Myend   = _My_data._Myend;
; 1655 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1656 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1657 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1658 : 
; 1659 :         if (_Newcapacity > max_size()) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00006	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000b	77 09		 ja	 SHORT $LN7@Buy_nonzer

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0000d	89 45 08	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1664 :     }

  00010	5d		 pop	 ebp

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  00011	e9 00 00 00 00	 jmp	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
$LN7@Buy_nonzer:

; 1660 :             _Xlength();

  00016	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN5@Buy_nonzer:
  0001b	cc		 int	 3
?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1648 :     void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 :         // allocate array with _Newcapacity elements
; 1650 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1651 :         auto& _My_data    = _Mypair._Myval2;
; 1652 :         pointer& _Myfirst = _My_data._Myfirst;
; 1653 :         pointer& _Mylast  = _My_data._Mylast;
; 1654 :         pointer& _Myend   = _My_data._Myend;
; 1655 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1656 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1657 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1658 : 
; 1659 :         if (_Newcapacity > max_size()) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00006	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000b	77 09		 ja	 SHORT $LN7@Buy_nonzer

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0000d	89 45 08	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1664 :     }

  00010	5d		 pop	 ebp

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  00011	e9 00 00 00 00	 jmp	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
$LN7@Buy_nonzer:

; 1660 :             _Xlength();

  00016	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN5@Buy_nonzer:
  0001b	cc		 int	 3
?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ PROC ; std::vector<char const *,std::allocator<char const *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z PROC ; std::forward<std::allocator<char const *> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z ENDP ; std::forward<std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$distance@PBQBD@std@@YAHPBQBD0@Z
_TEXT	SEGMENT
??$distance@PBQBD@std@@YAHPBQBD0@Z PROC			; std::distance<char const * const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1704 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00000	2b d1		 sub	 edx, ecx
  00002	c1 fa 02	 sar	 edx, 2
  00005	8b c2		 mov	 eax, edx

; 1706 :     } else {
; 1707 :         _Adl_verify_range(_First, _Last);
; 1708 :         auto _UFirst             = _Get_unwrapped(_First);
; 1709 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1710 :         _Iter_diff_t<_InIt> _Off = 0;
; 1711 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :             ++_Off;
; 1713 :         }
; 1714 : 
; 1715 :         return _Off;
; 1716 :     }
; 1717 : }

  00007	c3		 ret	 0
??$distance@PBQBD@std@@YAHPBQBD0@Z ENDP			; std::distance<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z PROC ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 03	 sar	 edi, 3
  0001a	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z PROC ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z ENDP ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z PROC ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::distance<SegmentFramework::RelocatedNetVar const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1704 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00000	2b d1		 sub	 edx, ecx
  00002	c1 fa 03	 sar	 edx, 3
  00005	8b c2		 mov	 eax, edx

; 1706 :     } else {
; 1707 :         _Adl_verify_range(_First, _Last);
; 1708 :         auto _UFirst             = _Get_unwrapped(_First);
; 1709 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1710 :         _Iter_diff_t<_InIt> _Off = 0;
; 1711 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :             ++_Off;
; 1713 :         }
; 1714 : 
; 1715 :         return _Off;
; 1716 :     }
; 1717 : }

  00007	c3		 ret	 0
??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::distance<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 03	 sar	 edi, 3
  0001e	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z PROC ; std::forward<std::less<char const *> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z ENDP ; std::forward<std::less<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z PROC ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 02	 sar	 edi, 2
  0001a	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z ENDP ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z PROC	; std::_Get_unwrapped<char const * const * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z ENDP	; std::_Get_unwrapped<char const * const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z PROC ; std::_Unfancy<SegmentFramework::RelocatedNetVar>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z ENDP ; std::_Unfancy<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z PROC ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z ENDP ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 03	 sar	 edi, 3
  0001a	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z PROC ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z ENDP ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z PROC ; std::_Copy_memmove<char const * const *,char const * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z ENDP ; std::_Copy_memmove<char const * const *,char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z PROC ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z ENDP ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
END
